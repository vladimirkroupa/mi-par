\documentclass[12pt]{article}
\usepackage{epsf,epic,eepic,eepicemu}
%\documentstyle[epsf,epic,eepic,eepicemu]{article}
\usepackage[utf8]{inputenc}

\begin{document}
%\oddsidemargin=-5mm \evensidemargin=-5mm \marginparwidth=.08in
%\marginparsep=.01in \marginparpush=5pt \topmargin=-15mm
%\headheight=12pt \headsep=25pt \footheight=12pt \footskip=30pt
%\textheight=25cm \textwidth=17cm \columnsep=2mm \columnseprule=1pt
%\parindent=15pt\parskip=2pt

\begin{center}
\bf Semestrální projekt MI-PAR 2012/2013:\\[5mm]
    Paralelní algoritmus pro hledání minimální kostry grafu\\[5mm]
       Vladimír Kroupa\\
       Jan Stadler\\[2mm]
\end{center}

\section{Definice problému a popis sekvenčního algoritmu}

Nalezněte kostru grafu G (strom) s minimálním stupněm. Stupeň stromu je definován jako maximální stupeň ze všech uzlů stromu. Výstupem algoritmu je výpis kostry grafu G a hodnota stupně této kostry. Vstupem je  jednoduchý souvislý neorientovaný neohodnocený graf o $n$ uzlech a $m$ hranách, $n \in N, n \ge 5$, $k \in N, n \ge k \ge 3 $.

Řešení existuje vždy, vždy lze sestrojit kostru grafu. Sekvenční algoritmus je typu BB-DFS s hloubkou prohledávaného prostoru omezenou na $\vert$V$\vert$. Přípustný mezistav je definovaný částečnou kostrou. Přípustný koncový stav je vytvořená kostra. Algoritmus končí po prohledání celého prostoru či při dosažení dolní meze. Cena, kterou minimalizujeme, je stupeň kostry.

Těsná dolní mez je rovna 2. Horní mez je rovna nejvyššímu stupni v grafu G.

Pro usnadnění paralelizace řešení je použit explicitní zásobník, na který jsou ukládány jednotlivé stavy. Partikulární řešení se skládá z částečné kostry, reprezentované seznamem hran tvořících kostru a polem stupňů jednotlivých vrcholů, které částečná kostra obsahuje. Pole stupňů slouží k snadnému výpočtu maximálního stupně kostry (stačí pouze najít maximální prvek pole). Zároveň je použito při hledání hran, které lze do částečné kostry přidat. 

Použitý algoritmus je naivní, postupným přidáváním hran kostry prochází možné permutace hran, které vedou na kostru grafu. Použitím branch-and-bound strategie je ale významně zredukován počet procházených stavů.

Na zásobník se vkládají uzly grafu, které je možné přidat do existující částečné kostry. Mimo to se na zásobník vkládá symbol pro backtrack. Pokud je sejmut z vrcholu zásobníku tento symbol, je jasné, že jsme vyčerpali sourozenecké uzly stromu stavového prostoru a další prvek zásobníku bude rodičovský stav těchto sourozeneckých uzlů. Musíme tedy opravit partikulární řešení odstraněním poslední přidané hrany částečné kostry (což zahrnuje i aktualizaci pole stupňů vrcholů kostry).

Hlavní smyčka algoritmu probíhá následovně. Na počátku vložíme na zásobník hrany incidentní s vrcholem 0. Dokud není zásobník prázdný, snímáme z něj hrany. Po sejmutí prvku zkontrolujeme, zda se nejedná o backtrack symbol. Pokud ano, opravíme partikulární řešení. V opačném případě hranu přidáme do partikulárního řesení --- na konec seznamu hran částečné kostry. Otestujeme, zda částečná kostra již není kostrou grafu. To zjistíme snadno, počet hran kostry je roven počtu vrcholů grafu $-1$.

Pokud již máme řešení (kostru grafu), zjistíme její cenu (maximální vrchol kostry). Pokud je cena řešení rovná dolní mezi (2), ukončíme výpočet a vrátíme kostru. Pokud je cena vyšší než dolní mez, ale nižší, než cena nejlepšího doposud nalezeného řešení, aktualizujeme nejlepší řešení. Protože nyní se nacházíme v listu stromu stavového prostoru, opravíme partikulární řešení odstraněním poslední hrany.

Pokud řešení nemáme, expandujeme současný stav. Vložíme na zásobník symbol pro backtrack a dále vložíme všechny kandidátské hrany. Kandidátské hrany získáme tak, že nalezneme všechny hrany grafu, které mají jeden z vrcholů obsažen v aktuální částečné kostře a druhý vrchol v kostře doposud obsažen není. Každou z takto získaných hran zkusíme přidat do částečné kostry a vypočteme, jaký maximální stupeň by kostra měla po přidání této hrany. Ze seznamu těchto hran následně odstraníme ty, které by vedly na vyšší stupeň kostry, než je stupeň nejlepšího doposud nalezeného řešení.

Algoritmus terminuje buď nalezením řešení s cenou rovnou dolní mezi, nebo vyčerpáním zásobníku stavů. Po vyčerpání zásobníku musí nutně existovat alespoň jedno řešení.

Vstupem pro program je matice sousednosti, kde prvky jsou oddělené mezerami. Na prvním řádku před samotnou maticí je počet vrchovů grafu. Výstupem je kostra grafu a její vrchol.

!! Uveïte tabulku nameøených èasù sekvenèního algoritmu pro rùznì velká data. !!!

\section{Popis paralelního algoritmu a jeho implementace v MPI}

Paralelní algoritmus je typu L-PBB-DFS-D. Každý procesor si udržuje informaci o lokálně nejlepším řešení a pokud řešení s cenou rovnou dolní mezi neexistuje, bude prohledávat celý stavový prostor a po distribuovaném ukončení výpočtu pomocí algoritmu ADUV bude globálně nejlepší řešení získáno paralelní redukcí lokálních řešení. Existuje-li řešení s cenou rovnou dolní mezi, procesor, který jej nalezne, ukončí výpočet vysláním zprávy typu jeden-všem.

Modifikace algoritmu pro paralelní zpracování je následující. Proces 0 načte matici sousednosti ze vstupního souboru. Poté rozešle ostatním procesům počet vrcholů grafu pomocí \texttt{MPI\_Bcast}. Nakonec rozešle pomocí \texttt{MPI\_Bcast} prvky matice. Proces 0 také na počátku výpočtu provede úvodní rozdělení práce ostatním procesům. Úvodní rozdělení funguje tak, že proces 0 expanduje stavy na zásobníku, dokud na zásobníku není tolik hran, kolik je procesů. ?? porovnání rychlosti běhu s dist a bez? ??

Hlavní změna oproti sekvenčnímu algoritmu je, že hlavní smyčka nemá jako podmínku ukončení neprázdný zásobník stavů, ale výsledek volání metody \texttt{shouldTerminate()}. Tato metoda se volá pouze jednou za \texttt{WORK\_STEPS} kroků, v ostatních případech algoritmus pokračuje v hledání. Tím je omezena režie na komunikaci mezi procesy. Parametr \texttt{WORK\_STEPS} je zadán jako argument při spuštění.

\subsection{Metoda \texttt{shouldTerminate()}}

Metoda \texttt{shouldTerminate()} nejdříve zkontroluje (\texttt{MPI\_Iprobe()}), zda proces nemá zprávu, požadující ukončení. Tuto zprávu vysílá proces 0 na konci distribuovaného ukončování výpočtu. Také ji vyslat jakýkoliv proces, pokud narazí na řešení s cenou rovnou dolní mezi (nejlepší možné řešení). 

Pokud povel k ukončení není přítomen, proces zjistí, zda má práci, o kterou se může podělit (nejméně 2 hrany na zásobníku stavů). Pokud nemá dostatek práce, zkontroluje a přijme (\texttt{MPI\_Iprobe(), MPI\_Recv()}) požadavky na práci jemu adresované. Všem procesům od kterých přišly tyto požadavky zašle odmítnutí.

!!! Hledání dárce. !!!

Popište paralelní algoritmus, opìt vyjdìte ze zadání a pøesnì
vymezte odchylky, zvláštì u algoritmu pro vyvažování zátìže, hledání
dárce, ci ukonèení výpoètu.  Popište a vysvìtlete strukturu
celkového paralelního algoritmu na úrovni procesù v MPI a strukturu
kódu jednotlivých procesù. Napø. jak je naimplementována smyèka pro
èinnost procesù v aktivním stavu i v stavu neèinnosti. Jaké jste
zvolili konstanty a parametry pro škálování algoritmu. Struktura a
sémantika pøíkazové øádky pro spouštìní programu.

\section{Namìøené výsledky a vyhodnocení}

\begin{enumerate}
\item Zvolte tøi instance problému s takovou velikostí vstupních dat, pro které má
sekvenèní algoritmus èasovou složitost kolem 5, 10 a 15 minut. Pro
meøení èas potøebný na ètení dat z disku a uložení na disk
neuvažujte a zakomentujte ladící tisky, logy, zprávy a výstupy.
\item Mìøte paralelní èas pøi použití $i=2,\cdot,32$ procesorù na sítích Ethernet a InfiniBand.
\item Z namìøených dat sestavte grafy zrychlení $S(n,p)$. Zjistìte, zda a za jakych podmínek
došlo k superlineárnímu zrychlení a pokuste se je zdùvodnit.
\item Vyhodnoïte komunikaèní složitost dynamického vyvažování zátìže a posuïte
vhodnost vámi implementovaného algoritmu pro hledání dárce a dìlení
zásobníku pri øešení vašeho problému. Posuïte efektivnost a
škálovatelnost algoritmu. Popište nedostatky vaší implementace a
navrhnìte zlepšení.
\item Empiricky stanovte
granularitu vaší implementace, tj., stupeò paralelismu pro danou
velikost øešeného problému. Stanovte kritéria pro stanovení mezí, za
kterými již není uèinné rozkládat výpoèet na menší procesy, protože
by komunikaèní náklady prevážily urychlení paralelním výpoètem.

\end{enumerate}

\section{Závìr}

Celkové zhodnocení semestrální práce a zkušenosti získaných bìhem
semestru.

\section{Literatura}

\appendix

\section{Návod pro vkládání grafù a obrázkù do Latexu}

Nejjednodušší zpùsob vytvoøení obrázku je použít vektorový grafický
editor (napø. xfig nebo jfig), ze kterého lze exportovat buï
\begin{itemize}
\item postscript formáty (ps nebo eps formát) nebo
\item latex formáty (v poøadí prostý latex, latex s macry epic, eepic, eepicemu). Uvedené poøadí odpovídá rùstu
komplikovanosti obrázkù který formát podporuje (prostá latex macra
umožnují pouze jednoduché, epic makra nìco mezi, je tøeba
vyzkoušet).

\end{itemize}
Následující pøíklady platí pro všechny pøípady.

Obrázek v postscriptu, vycentrovaný a na celou šíøku stránky, s
popisem a èíslem. Všimnete si, jak øídit velikost obrazku.
\begin{figure}[ht]
\epsfysize=3cm \centerline{\epsfbox{VasObrazek.eps}} \caption{Popis
vašeho obrazku} \label{labelvasehoobrazku}
\end{figure}

Obrázek pouze vložený mezi øádky textu, bez popisu a èíslování.\\
\epsfxsize=1cm
\rule{0pt}{0pt}\hfill\epsfbox{VasObrazek.eps}\hfill\rule{0pt}{0pt}

Latexovské obrázky maji pøípony *.latex, *.epic, *.eepic, a
*.eepicemu, respective.
%\begin{figure}[ht]
%\begin{center}
%\input VasObrazek.latex
%\end{center}
%\caption{Popis vašeho obrázku} \label{l1}
%\end{figure}
Vypuštením závorek {\tt figure} dostanete opìt pouze rámeèek v textu
bez èísla a popisu.

Takhle jednoduše mùžete poskládat obrázky vedle sebe.
%\begin{center}
%\setlength{\unitlength}{0.1mm}\input VasObrazek.epic
%\hglue 5mm
%\setlength{\unitlength}{0.15mm}\input VasObrazek.eepic
%\hglue 5mm
%\setlength{\unitlength}{0.2mm}\input VasObrazek.eepicemu
%\end{center}
Øídit velikost latexovskych obrázkù lze pøíkazem
\begin{verbatim}
\setlength{\unitlength}{0.1mm}
\end{verbatim}
které mìní mìøítko rastru obrázku, Tyto pøíkazy je ale souèasnì
nutné vyhodit ze souboru, který xfig vygeneroval.

Pro vytváøení grafu lze použít program gnuplot, který umí generovat
postscriptovy soubor, ktery vložíte do Latexu výše uvedeným
zpùsobem.

\end{document}
